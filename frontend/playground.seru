from webidl`github.com/Serulian/virtualdom` import document, Node, Element, Text, HTMLDocument, HTMLIFrameElement
from webidl`github.com/Serulian/corelib:master` import Number
from webidl`timeout` import setTimeout, clearTimeout

from "github.com/Serulian/component" import RenderComponent, UpdateComponentState
from "github.com/Serulian/request" import Post
from "github.com/Serulian/virtualdom" import Context, Div, Button, If, Span, TextArea, IFrame, HideIf
from "github.com/Serulian/virtualdom" import Nav, Ul, Li, A, DynamicAttributes, Pre
from codeeditor import CodeEditor

/**
 * BuildResult holds the result of calling the toolkit to perform a build.
 */
struct BuildResult {
	/**
	 * Status is the status code from calling the toolkit executable.
	 */
	Status int

	/**
	 * Output is the console output from the tookkit.
	 */
	Output string

	/**
	 * GeneratedSourceFile is the generated source for the program, if Status == 0.
	 */
	GeneratedSourceFile string

	/**
	 * GeneratedSourceMap is the generated sourcemap for the program, if Status == 0.
	 */
	GeneratedSourceMap string
}

/**
 * playgroundState holds the state of the playground app or embeded editoor.
 */
struct playgroundState {
	working bool
	currentCode string
	initialCode string
	serverError bool
	buildResult BuildResult?
	currentView string
	consoleOutput string
}

/**
 * playgroundBase is a base for the App and PlaygroundEditor components.
 */
class playgroundBase {
	var<playgroundState> state
	var<Number?> timerHandle
	var<string?> consoleOutputBuffer

	function<void> StateUpdated(state any) {
		this.state = state.(playgroundState)
	}

	function<void> runProject() {
		// Set the project as running.
		UpdateComponentState(this, this.state{
			working: true,
			serverError: false,
			buildResult: null,
			currentView: 'edit',
			consoleOutput: '',
		})

		// Make an XHR request with the code over to the playground service.
		response, _ := Post('/play/build', this.state.currentCode)
		if response is null {
			UpdateComponentState(this, this.state{
				working: false,
				serverError: true,
				buildResult: null,
				currentView: 'edit',
			})
		} else if response.StatusCode == 200 {
			result := BuildResult.Parse<json>(response.Text)
			UpdateComponentState(this, this.state{
				working: false,
				serverError: false,
				buildResult: result,
				currentView: 'frame' if result.Status == 0 else 'output',
			})
		} else {
			UpdateComponentState(this, this.state{
				working: false,
				serverError: true,
				buildResult: null,
				currentView: 'edit',
			})
		}
	}

	function<void> codeChanged(value string) {
		UpdateComponentState(this, this.state{currentCode: value})
	}

	function<void> updateConsole() {
		buffer := this.consoleOutputBuffer ?? ''
		this.consoleOutputBuffer = null

		UpdateComponentState(this, this.state{
			consoleOutput: (this.state.consoleOutput + buffer + '\n').Trim(),
		})

		this.timerHandle = null
		if this.consoleOutputBuffer is not null {
			this.updateConsole()
		}
	}

	function<void> registerConsoleUpdater() {
		if this.timerHandle is not null {
			return;
		}

		this.timerHandle = setTimeout(this.updateConsole, 100)
	}

	function<void> emitCode(iframeNode Node) {
		sourceCode := this.state.buildResult?.GeneratedSourceFile ?? ''

		iframeElement := iframeNode.(HTMLIFrameElement)
		iframeDoc := iframeElement.contentWindow.document

		// Add the <script> tag for the compiled code.
		scriptTag := iframeDoc.createElement('script')
		scriptTag.setAttribute('type', 'text/javascript')
		scriptTag.appendChild(iframeDoc.createTextNode(sourceCode))
		iframeDoc.body.appendChild(scriptTag)

		// Register a handler on the iframeElement that will be invoked from within the iframe for console.log.
		iframeElement[&'handler'] = function<void>(message string) {
			// Note: Since this method will be called without awaiting (since JS has no idea
			// how to await a console.log), we buffer any console output given and have a timer update it
			// batch, to prevent multiple instances of these calls running at the same time which causes
			// DOM diffing issues.
			this.consoleOutputBuffer = (this.consoleOutputBuffer ?? '') + message + '\n'
			this.registerConsoleUpdater();
		}

		// Add the <script> tag for starting the program and override
		// the console.log so it shows up in the playground.
		startCode := `
			var oldLog = window.console.log;
			window.console.log = function(msg) {
				oldLog.apply(this, arguments);
				window.frameElement.handler(msg);
			};

			window.Serulian.then(function(global) {
				global.playground.Run();
			});
		`

		loadScriptTag := iframeDoc.createElement('script')
		loadScriptTag.setAttribute('type', 'text/javascript')
		loadScriptTag.appendChild(iframeDoc.createTextNode(startCode))
		iframeDoc.body.appendChild(loadScriptTag)
	}

	function<any> Render(context Context) {
		return null
	}
}

/**
 * App is the root component for the playground application.
 */
class App : playgroundBase {
	constructor Declare() {
		return App{
			state: playgroundState{
				working: false,
				currentCode: '',
				initialCode: '',
				serverError: false,
				currentView: '',
				consoleOutput: '',
			},
		}
	}

	function<any> Render(context Context) {
		// Note: lack of indentation is important here so the initial code is properly
		// indented in the code editor.
		initialCode := `from "github.com/Serulian/debuglib:master" import Log

function<any> Run() {
	// Note: open the browser console to see Log outputs.
	Log('hello world!')
	return true
}`

		return <Div id="rootElement">
			<Nav className="navbar navbar-default" style="margin-bottom: 0px">
				<A className="navbar-brand" href="#">Serulian Playground</A>

				<Div className="navbar-form navbar-left" @If={!this.state.working}>
					<Button className="btn btn-primary" onclick={this.runProject}
					        @DynamicAttributes={{'disabled': this.state.currentCode.IsEmpty}}>
						Run
					</Button>
				</Div>

				<Div className="navbar-form navbar-left" @If={this.state.working}>
					<Div className="spinner" />
				</Div>

				<Div className="navbar-form navbar-left" @If={this.state.serverError}>
					A server error occurred. Please try again shortly.
				</Div>
			</Nav>

			<Div className="container-fluid editor-and-viewer">
				<Div className="row">
					<Div className="col-md-6 col-sm-12">
						<CodeEditor IsReadOnly={this.state.working} OnChanged={this.codeChanged}>
							{initialCode}
						</CodeEditor>
					</Div>

					<Div className="col-md-6 col-sm-12">
						<Div style="text-align: center; margin-top: 20px;"
						     @If={this.state.buildResult?.GeneratedSourceFile is null}
						     @If={!this.state.working}>
							<Span className="glyphicon glyphicon-arrow-left" /> Enter some code and hit "Run"
						</Div>

						<Div style="text-align: center; margin-top: 20px;" @If={this.state.working}>
							Building...
						</Div>

						<IFrame ondomnodeinserted={this.emitCode}
						        sandbox="allow-forms allow-popups allow-scripts allow-same-origin allow-modals"
						        frameborder="0"
						        @If={!(this.state.buildResult?.GeneratedSourceFile?.IsEmpty ?? true)} />
					</Div>
				</Div>

				<Div className="row" @If={this.state.buildResult is not null}
				     @If={!this.state.working}>
					<Div className="col-md-12">
						<Pre className="build-result">{this.state.buildResult?.Output}</Pre>
					</Div>
				</Div>
			</Div>
		</Div>
	}
}

/**
 * Start starts the playground user interface, attaching it to the given DOM element.
 */
function<void> Start(element Element) {
	RenderComponent(<App />, element)
}

/**
 * PlaygroundEditor is a component displaying an inline playground element.
 */
class PlaygroundEditor : playgroundBase {
	constructor Declare(attributes []{string}, code string) {
		return PlaygroundEditor{
			state: playgroundState{
				working: false,
				currentCode: code,
				initialCode: code,
				serverError: false,
				currentView: 'edit',
				consoleOutput: '',
			},
		}
	}

	function<void> showEditTab() {
		UpdateComponentState(this, this.state{currentView: 'edit'})
	}

	function<void> showOutputTab() {
		UpdateComponentState(this, this.state{currentView: 'output'})
	}

	function<void> showFrameTab() {
		UpdateComponentState(this, this.state{currentView: 'frame'})
	}

	function<any> Render(context Context) {
		// Make the height = # lines in the content * 16 + 50px, with a max of ~1000px
		var<string> height = 'auto';
		if !this.state.initialCode.IsEmpty {
			lineCount := this.state.initialCode.Split('\n').Length
			var<int> heightPx = (lineCount * 16) + 50
			if heightPx > 1000 {
				heightPx = 1000
			}

			height = `${heightPx}px`
		}

		return <Div className="playgroundEditor" style={'height: ' + height}>
			<Div className="pane" @HideIf={this.state.currentView != 'edit'}>
				<CodeEditor IsReadOnly={this.state.working} OnChanged={this.codeChanged}
				            Theme="chrome" Mode="text">
					{this.state.currentCode.Trim()}
				</CodeEditor>
			</Div>

			<Div className="pane" @HideIf={this.state.currentView != 'output'}>
				<Pre className="build-result" @If={this.state.buildResult is not null}>
					{this.state.buildResult?.Output}
				</Pre>
			</Div>

			<Div className="pane" @HideIf={this.state.currentView != 'frame'}>
				<Pre className="console-output" @HideIf={this.state.consoleOutput.IsEmpty}>{this.state.consoleOutput}</Pre>

				<IFrame ondomnodeinserted={this.emitCode}
				        sandbox="allow-forms allow-popups allow-scripts allow-same-origin allow-modals"
				        frameborder="0"
				        @If={!(this.state.buildResult?.GeneratedSourceFile?.IsEmpty ?? true)} />
			</Div>

			<Div className="toolbar">
				<Ul className="tabs">
					<Li className={'active' if this.state.currentView == 'edit' else ''}
					    onclick={this.showEditTab}>
						Code
					</Li>
					<Li className={'active' if this.state.currentView == 'output' else ''}
					    onclick={this.showOutputTab} @If={this.state.buildResult is not null}>
						Output
					</Li>
					<Li className={'active' if this.state.currentView == 'frame' else ''}
					    onclick={this.showFrameTab}
					    @If={!(this.state.buildResult?.GeneratedSourceFile?.IsEmpty ?? true)}>
						Compiled
					</Li>
				</Ul>

				<Button className="btn btn-primary" onclick={this.runProject}
				        @If={!this.state.working}>
					Run
				</Button>

				<Div className="spinner" @If={this.state.working} />

				<Div className="server-error" @If={this.state.serverError}>
					A server error occurred. Please try again shortly.
				</Div>
			</Div>
		</Div>
	}
}

/**
 * DecorateEditors replaces all playgroundeditor tags in the DOM with an associated editor.
 */
function<void> DecorateEditors() {
	elements := document.getElementsByTagName('playgroundeditor')
	for i in 0 .. int(elements.length) - 1 {
		editorElement := elements[&i].(Element)
		firstChild := editorElement.firstChild

		var initialCode = ''
		if firstChild is not null {
			initialCode = string(firstChild.(Text).wholeText)
		}

		editorElement.setAttribute('className', '')
		RenderComponent(<PlaygroundEditor>{initialCode}</PlaygroundEditor>, editorElement)
	}
}
